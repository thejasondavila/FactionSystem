-- // FACTIONHANDLER MODULE SCRIPT LOCATED IN SERVERSCRIPTSERVICE // --

--[[
	FACTION SYSTEM
	Author: Celuxis
	Version: 2.1 (HiddenDevs Application, includes more comments)
	Last Updated: November 2025
--]]

-- SERVICE DECLARATIONS
local DataStoreService = game:GetService("DataStoreService") -- Gets the DataStoreService to enable persistent data storage across game sessions
local Players = game:GetService("Players") -- Gets the Players service to access player information and events
local MessagingService = game:GetService("MessagingService") -- Gets MessagingService for cross-server communication between different game servers

-- DATASTORE INITIALIZATION
-- Separate DataStores for different data types to optimize read/write operations and reduce throttling
local FactionsStore = DataStoreService:GetDataStore("Factions_NEW") -- Creates/retrieves DataStore for storing complete faction data structures
local PlayerFactionsStore = DataStoreService:GetDataStore("PlayerFactions_NEW") -- Creates/retrieves DataStore mapping player UserIds to their faction names
local RenownLeaderboard = DataStoreService:GetOrderedDataStore("FactionRenown_NEW") -- Creates/retrieves OrderedDataStore for sorted faction rankings by renown points
local FactionJoinCodes = DataStoreService:GetDataStore("FactionJoinCodes_NEW") -- Creates/retrieves DataStore mapping 7-digit join codes to faction names
local FactionTerritories = DataStoreService:GetDataStore("FactionTerritories_NEW") -- Creates/retrieves DataStore for faction territory claim data

-- CACHE SYSTEM
local factionCache = {} -- Dictionary storing complete faction data in memory: {[factionName] = factionData}
local playerFactionCache = {} -- Dictionary mapping player UserIds to their faction name: {[userId] = factionName}
local territoryCache = {} -- Dictionary storing faction territory data for quick spatial lookups: {[factionName] = territoryData}
local cacheExpirationTimes = {} -- Dictionary tracking expiration timestamps for each faction's cached data: {[factionName] = expirationTimestamp}
local CACHE_REFRESH_INTERVAL = 300 -- Constant defining base cache lifetime in seconds (5 minutes)

-- OPTIMIZATION SYSTEMS
local pendingRenown = {} -- Dictionary accumulating renown changes before DataStore write: {[factionName] = accumulatedAmount}
local RENOWN_BATCH_INTERVAL = 60 -- Constant defining how often (in seconds) to flush accumulated renown to DataStore
local RENOWN_BATCH_THRESHOLD = 10 -- Constant defining accumulated renown threshold that triggers immediate flush

local lastBroadcast = {} -- Dictionary tracking last MessagingService broadcast time per faction: {[factionName] = timestamp}
local BROADCAST_COOLDOWN = 30 -- Constant defining minimum seconds between MessagingService broadcasts per faction

local playerLastRequest = {} -- Dictionary tracking last operation time per player: {[userId] = {[operation] = timestamp}}
local PLAYER_OPERATION_COOLDOWN = 2 -- Constant defining minimum seconds between operations per player

-- CONSTANTS
local LEADER_RANK_NUMBER = 20 -- Constant defining the highest rank number (reserved for faction leader)
local DEFAULT_RANK_NUMBER = 1 -- Constant defining the rank number assigned to new members
local ARMORY_CAPACITY = 10 -- Constant defining maximum number of items in faction armory
local MAX_MEMBERS = 50 -- Constant defining maximum members allowed per faction
local TERRITORY_RADIUS = 100 -- Constant defining default territory radius in studs for spatial calculations

-- MESSAGINGSERVICE TOPICS
local FACTION_UPDATE_TOPIC = "FactionUpdates" -- String constant defining MessagingService topic for faction data change broadcasts
local FACTION_KICK_TOPIC = "FactionKicks" -- String constant defining MessagingService topic for player kick notifications

-- MAIN MODULE TABLE
local Factions = {} -- Main module table that will be returned and contains all public functions

-- METATABLE IMPLEMENTATION
local FactionMeta = {} -- Table that will serve as the metatable for faction objects
FactionMeta.__index = FactionMeta -- Sets __index metamethod to itself, enabling method calls on faction objects

-- Metatable constructor: Creates a new Faction object from raw data
function FactionMeta.new(factionData) -- Function that constructs a new faction object from raw data table
	local self = setmetatable({}, FactionMeta) -- Creates empty table and sets FactionMeta as its metatable, enabling OOP methods
	
	for key, value in pairs(factionData) do -- Iterates through all key-value pairs in the raw faction data
		self[key] = value -- Copies each property from raw data to the new faction object
	end
	
	return self -- Returns the newly constructed faction object with metatable attached
end

-- Metamethod: Provides string representation of faction for debugging
function FactionMeta:__tostring() -- Metamethod that defines how faction objects are converted to strings
	return string.format("Faction[%s] - Members: %d, Renown: %d, Leader: %d", -- Uses string.format for formatted output
		self.Name, -- Accesses faction's Name property
		self:GetMemberCount(), -- Calls GetMemberCount method to calculate current member count
		self:GetRenown(), -- Calls GetRenown method to get total renown including pending amounts
		self.Leader -- Accesses faction's Leader UserId property
	)
end

-- Method: Get total number of members in the faction
function FactionMeta:GetMemberCount() -- Method that calculates total members by iterating through Members dictionary
	local count = 0 -- Initializes counter variable to zero
	for _ in pairs(self.Members) do -- Iterates through Members dictionary, discarding keys/values with underscore
		count = count + 1 -- Increments counter by one for each member entry
	end
	return count -- Returns the final member count
end

-- Method: Get current renown (including pending batched renown)
function FactionMeta:GetRenown() -- Method that calculates total renown including both stored and pending amounts
	local storedRenown = self.Renown or 0 -- Gets stored renown from faction data, defaulting to 0 if nil
	local pendingAmount = pendingRenown[self.Name] or 0 -- Gets pending renown from global pendingRenown table, defaulting to 0 if nil
	return storedRenown + pendingAmount -- Returns sum of stored and pending renown
end

-- Method: Check if faction is at member capacity
function FactionMeta:IsFull() -- Method that checks if faction has reached maximum member limit
	return self:GetMemberCount() >= MAX_MEMBERS -- Returns boolean: true if member count equals or exceeds MAX_MEMBERS constant
end

-- Method: Check if a user is a member of this faction
function FactionMeta:IsMember(userId) -- Method that checks if a given userId exists in faction's Members dictionary
	return self.Members[tostring(userId)] ~= nil -- Returns boolean: true if userId key exists in Members dictionary
end

-- Method: Get a member's rank object
function FactionMeta:GetMemberRank(userId) -- Method that retrieves a member's rank data structure
	local rankName = self.Members[tostring(userId)] -- Gets the rank name string associated with this userId
	if not rankName then -- Checks if rank name is nil (member doesn't exist)
		return nil -- Returns nil to indicate member not found
	end
	
	return self:FindRank(rankName) -- Calls FindRank method to retrieve full rank object by name
end

-- Method: Find a rank by name
function FactionMeta:FindRank(rankName) -- Method that searches for a rank object by its name
	for _, rank in ipairs(self.Ranks) do -- Iterates through Ranks array using ipairs for ordered traversal
		if rank.RankName == rankName then -- Compares current rank's RankName property to search parameter
			return rank -- Returns the rank object if name matches
		end
	end
	return nil -- Returns nil if no matching rank found after checking all ranks
end

-- Method: Check if a user has a specific permission
function FactionMeta:HasPermission(userId, permission) -- Method that checks if a user has a specific permission string
	if self.Leader == userId then -- Checks if userId matches faction's Leader property
		return true -- Returns true immediately because leaders have all permissions
	end
	
	local rank = self:GetMemberRank(userId) -- Calls GetMemberRank to retrieve user's rank object
	if not rank then -- Checks if rank is nil (user not a member)
		return false -- Returns false because non-members have no permissions
	end
	
	return rank.Permissions and rank.Permissions[permission] == true -- Returns boolean: true if Permissions table exists AND permission key is true
end

-- Method: Check if manager can manage target based on rank hierarchy
function FactionMeta:CanManageUser(managerId, targetUserId) -- Method that validates rank hierarchy for management actions
	if managerId == targetUserId then -- Checks if manager and target are the same person
		return false -- Returns false because users cannot manage themselves
	end
	
	local managerRank = self:GetMemberRank(managerId) -- Gets manager's rank object
	local targetRank = self:GetMemberRank(targetUserId) -- Gets target's rank object
	
	if not managerRank or not targetRank then -- Checks if either rank is nil using OR operator
		return false -- Returns false if either user is not a member
	end
	
	return managerRank.RankNumber > targetRank.RankNumber -- Returns boolean: true if manager's rank number is greater (higher rank)
end

-- Method: Convert faction object back to raw data for DataStore storage
function FactionMeta:ToRawData() -- Method that converts faction object to plain table for DataStore serialization
	local rawData = {} -- Creates empty table to store raw data properties
	
	for key, value in pairs(self) do -- Iterates through all properties of the faction object
		if type(value) ~= "function" then -- Checks if value type is not a function (excludes metatable methods)
			rawData[key] = value -- Copies non-function properties to raw data table
		end
	end
	
	return rawData -- Returns the plain table suitable for DataStore storage
end

-- TERRITORY SYSTEM (CFrame Mathematics)

-- Method: Calculate if a position is within the faction's territory
function FactionMeta:IsPositionInTerritory(position) -- Method that uses Vector3 mathematics to check if position is within territory sphere
	if not self.Territory then -- Checks if Territory property is nil (no territory claimed)
		return false -- Returns false because faction has no territory to check against
	end
	
	local territoryCenter = self.Territory.Center -- Extracts the Vector3 center position of the territory sphere
	local territoryRadius = self.Territory.Radius -- Extracts the numeric radius of the territory sphere in studs
	
	local displacement = position - territoryCenter -- Subtracts center from position to get displacement Vector3 from center to position
	
	local distance = displacement.Magnitude -- Calculates Euclidean distance using Vector3.Magnitude property (sqrt(x²+y²+z²))
	
	return distance <= territoryRadius -- Returns boolean: true if calculated distance is less than or equal to radius
end

-- Method: Get all corners of the territory bounding box (demonstrates CFrame usage)
function FactionMeta:GetTerritoryBounds() -- Method that calculates 8 corners of territory bounding box using CFrame transformations
	if not self.Territory then -- Checks if Territory property is nil
		return nil -- Returns nil because no territory exists to calculate bounds for
	end
	
	local center = self.Territory.Center -- Extracts Vector3 center position
	local radius = self.Territory.Radius -- Extracts numeric radius value
	
	local territoryCFrame = CFrame.new(center) -- Creates CFrame at territory center with default orientation (no rotation)
	
	local corners = { -- Creates table containing 8 corner positions
		territoryCFrame:PointToWorldSpace(Vector3.new(radius, radius, radius)), -- Transforms local offset (+,+,+) to world space using CFrame transformation
		territoryCFrame:PointToWorldSpace(Vector3.new(radius, radius, -radius)), -- Transforms local offset (+,+,-) to world space
		territoryCFrame:PointToWorldSpace(Vector3.new(radius, -radius, radius)), -- Transforms local offset (+,-,+) to world space
		territoryCFrame:PointToWorldSpace(Vector3.new(radius, -radius, -radius)), -- Transforms local offset (+,-,-) to world space
		territoryCFrame:PointToWorldSpace(Vector3.new(-radius, radius, radius)), -- Transforms local offset (-,+,+) to world space
		territoryCFrame:PointToWorldSpace(Vector3.new(-radius, radius, -radius)), -- Transforms local offset (-,+,-) to world space
		territoryCFrame:PointToWorldSpace(Vector3.new(-radius, -radius, radius)), -- Transforms local offset (-,-,+) to world space
		territoryCFrame:PointToWorldSpace(Vector3.new(-radius, -radius, -radius)) -- Transforms local offset (-,-,-) to world space
	}
	
	return corners -- Returns table containing all 8 corner Vector3 positions
end

-- UTILITY FUNCTIONS

-- Error logging function with consistent formatting
local function logError(operation, err) -- Function that logs errors with consistent format for debugging
	warn(string.format("[Factions] Error in %s: %s", operation, tostring(err))) -- Uses warn() to output formatted error message to console
end

-- Generate random 7-digit join code for faction invitations
local function generateJoinCode() -- Function that generates a random 7-digit numeric join code
	return tostring(math.random(1000000, 9999999)) -- Calls math.random with min/max range, converts number to string, and returns it
end

-- RATE LIMITING SYSTEM

local function checkPlayerRateLimit(userId, operation) -- Function that enforces per-player operation cooldowns to prevent spam
	local now = os.time() -- Gets current Unix timestamp in seconds using os.time()
	
	if not playerLastRequest[userId] then -- Checks if player has no entry in rate limit dictionary
		playerLastRequest[userId] = {} -- Initializes empty table for this player's operation timestamps
	end
	
	local lastTime = playerLastRequest[userId][operation] or 0 -- Gets last operation timestamp, defaulting to 0 if nil
	
	if now - lastTime < PLAYER_OPERATION_COOLDOWN then -- Subtracts last time from current time and checks if less than cooldown constant
		return false, "Please wait before performing this action again" -- Returns false and error message if cooldown not elapsed
	end
	
	playerLastRequest[userId][operation] = now -- Updates last request time to current timestamp
	return true, nil -- Returns true to indicate rate limit check passed, nil for no error message
end

-- CACHE MANAGEMENT

-- Set cache with randomized expiration time
local function setCacheWithExpiration(factionName, data) -- Function that caches faction data with staggered expiration
	factionCache[factionName] = data -- Stores faction data in cache dictionary using faction name as key
	
	local randomOffset = math.random(-60, 60) -- Generates random offset between -60 and +60 seconds to stagger cache expirations
	cacheExpirationTimes[factionName] = os.time() + CACHE_REFRESH_INTERVAL + randomOffset -- Calculates expiration timestamp by adding interval and random offset to current time
end

-- Periodic cache cleanup loop
task.spawn(function() -- Creates new asynchronous task that runs independently of main thread
	while true do -- Infinite loop that runs continuously
		task.wait(30) -- Yields execution for 30 seconds before continuing
		local now = os.time() -- Gets current Unix timestamp
		
		for factionName, expirationTime in pairs(cacheExpirationTimes) do -- Iterates through all cached faction expiration times
			if now >= expirationTime then -- Checks if current time has reached or passed expiration time
				factionCache[factionName] = nil -- Removes faction data from cache by setting to nil
				cacheExpirationTimes[factionName] = nil -- Removes expiration time entry by setting to nil
			end
		end
	end
end)

-- MESSAGINGSERVICE INTEGRATION

-- Broadcast faction update to all servers (with throttling to prevent spam)
local function broadcastFactionUpdate(factionName, updateType) -- Function that sends cross-server update notifications via MessagingService
	local now = os.time() -- Gets current Unix timestamp
	local lastTime = lastBroadcast[factionName] or 0 -- Gets last broadcast timestamp for this faction, defaulting to 0
	
	if now - lastTime < BROADCAST_COOLDOWN then -- Checks if enough time has passed since last broadcast
		return -- Exits function early without broadcasting if cooldown hasn't elapsed
	end
	
	lastBroadcast[factionName] = now -- Updates last broadcast timestamp to current time
	
	pcall(function() -- Wraps PublishAsync in pcall to catch and suppress any errors
		MessagingService:PublishAsync(FACTION_UPDATE_TOPIC, { -- Publishes message to all servers on specified topic
			FactionName = factionName, -- Includes faction name in message data
			UpdateType = updateType, -- Includes update type string in message data
			Timestamp = now -- Includes current timestamp in message data
		})
	end)
end

-- Listen for faction updates from other servers and invalidate local cache
pcall(function() -- Wraps SubscribeAsync in pcall to handle potential connection errors
	MessagingService:SubscribeAsync(FACTION_UPDATE_TOPIC, function(message) -- Subscribes to faction update topic with callback function
		local data = message.Data -- Extracts Data table from received message
		local factionName = data.FactionName -- Extracts faction name from message data
		
		factionCache[factionName] = nil -- Invalidates cached faction data by setting to nil
		cacheExpirationTimes[factionName] = nil -- Removes cache expiration entry by setting to nil
	end)
end)

-- Listen for player kicks from other servers
pcall(function() -- Wraps SubscribeAsync in pcall for error handling
	MessagingService:SubscribeAsync(FACTION_KICK_TOPIC, function(message) -- Subscribes to kick notification topic
		local kickedUserId = message.Data.UserId -- Extracts kicked player's UserId from message
		local player = Players:GetPlayerByUserId(kickedUserId) -- Attempts to find player instance on this server using UserId
		
		if player then -- Checks if player was found (is connected to this server)
			player:Kick("You have been removed from your faction.") -- Disconnects player with kick message
		end
	end)
end)

-- RENOWN BATCHING SYSTEM

-- Accumulate renown changes in memory
local function accumulateRenown(factionName, amount) -- Function that accumulates renown in memory before DataStore write
	pendingRenown[factionName] = (pendingRenown[factionName] or 0) + amount -- Adds amount to pending renown, initializing to 0 if nil
	
	if pendingRenown[factionName] >= RENOWN_BATCH_THRESHOLD then -- Checks if accumulated renown has reached threshold
		return Factions.FlushRenown(factionName) -- Immediately flushes to DataStore if threshold reached
	end
	
	return true, "Renown accumulated (will update shortly)" -- Returns success status and message
end

-- Flush accumulated renown to DataStore
function Factions.FlushRenown(factionName) -- Function that writes accumulated renown to DataStore
	local amount = pendingRenown[factionName] -- Gets accumulated renown amount for this faction
	
	if not amount or amount <= 0 then -- Checks if amount is nil or zero/negative
		return true, "No pending renown" -- Returns early if nothing to flush
	end
	
	pendingRenown[factionName] = nil -- Clears pending renown before write attempt
	
	local success, result = pcall(function() -- Wraps DataStore operation in pcall for error handling
		return FactionsStore:UpdateAsync(factionName, function(factionData) -- Uses UpdateAsync for atomic read-modify-write operation
			if not factionData then -- Checks if faction doesn't exist in DataStore
				return nil -- Returns nil to abort update
			end
			
			factionData.Renown = (factionData.Renown or 0) + amount -- Adds accumulated amount to stored renown, initializing to 0 if nil
			return factionData -- Returns modified data to save to DataStore
		end)
	end)
	
	if not success then -- Checks if pcall caught an error
		logError("FlushRenown", result) -- Logs the error using logging function
		pendingRenown[factionName] = (pendingRenown[factionName] or 0) + amount -- Restores pending renown since write failed
		return false, "Failed to flush renown" -- Returns failure status
	end
	
	if not result then -- Checks if UpdateAsync returned nil (faction doesn't exist)
		return false, "Faction does not exist" -- Returns failure status
	end
	
	pcall(function() -- Wraps OrderedDataStore update in pcall
		RenownLeaderboard:SetAsync(factionName, result.Renown) -- Updates leaderboard with new renown value
	end)
	
	setCacheWithExpiration(factionName, result) -- Updates cache with new faction data
	broadcastFactionUpdate(factionName, "Update") -- Notifies other servers of update
	return true, result.Renown -- Returns success status and new renown value
end

-- Periodic renown flushing background task
task.spawn(function() -- Creates asynchronous task for periodic flushing
	while true do -- Infinite loop
		task.wait(RENOWN_BATCH_INTERVAL) -- Waits for batch interval duration in seconds
		
		for factionName, amount in pairs(pendingRenown) do -- Iterates through all pending renown entries
			if amount > 0 then -- Checks if amount is positive
				Factions.FlushRenown(factionName) -- Flushes this faction's pending renown
			end
		end
	end
end)

-- Force flush all renown immediately (used during server shutdown)
function Factions.ForceFlushAllRenown() -- Function that immediately flushes all pending renown
	for factionName, amount in pairs(pendingRenown) do -- Iterates through all pending renown
		if amount > 0 then -- Checks if amount is positive
			Factions.FlushRenown(factionName) -- Flushes pending renown for this faction
		end
	end
end

-- PLAYER FACTION MANAGEMENT

-- Get the faction that a player belongs to
function Factions.GetPlayerFaction(userId) -- Function that retrieves which faction a player is in
	if playerFactionCache[userId] then -- Checks if player's faction is in cache
		return playerFactionCache[userId] -- Returns cached faction name immediately
	end
	
	local success, factionName = pcall(function() -- Wraps GetAsync in pcall for error handling
		return PlayerFactionsStore:GetAsync(tostring(userId)) -- Retrieves faction name from DataStore using userId as key
	end)
	
	if not success then -- Checks if GetAsync threw an error
		logError("GetPlayerFaction", factionName) -- Logs the error
		return nil -- Returns nil to indicate failure
	end
	
	if factionName then -- Checks if a faction name was found
		playerFactionCache[userId] = factionName -- Caches the faction name for future lookups
		return factionName -- Returns the faction name
	end
	
	return nil -- Returns nil if player is not in any faction
end

-- Save player's faction membership (internal function)
local function savePlayerFaction(userId, factionName) -- Function that saves or removes player's faction membership
	playerFactionCache[userId] = factionName -- Updates cache with new faction name (or nil)
	
	local success, err = pcall(function() -- Wraps DataStore operation in pcall
		if factionName then -- Checks if faction name is provided (not nil)
			PlayerFactionsStore:SetAsync(tostring(userId), factionName) -- Saves faction name to DataStore
		else
			PlayerFactionsStore:RemoveAsync(tostring(userId)) -- Removes player from DataStore if faction is nil
		end
	end)
	
	if not success then -- Checks if operation failed
		logError("savePlayerFaction", err) -- Logs error if write failed
	end
end

-- FACTION DATA OPERATIONS

-- Get faction information (returns Faction object with metatable methods)
function Factions.GetFactionInfo(factionName) -- Function that retrieves faction data as a metatable object
	if factionCache[factionName] then -- Checks if faction data is in cache
		return FactionMeta.new(factionCache[factionName]) -- Returns new faction object from cached data
	end
	
	local success, factionData = pcall(function() -- Wraps GetAsync in pcall
		return FactionsStore:GetAsync(factionName) -- Retrieves faction data from DataStore
	end)
	
	if not success then -- Checks if GetAsync threw error
		logError("GetFactionInfo", factionData) -- Logs error
		return nil -- Returns nil on failure
	end
	
	if factionData then -- Checks if faction exists
		setCacheWithExpiration(factionName, factionData) -- Caches the data with expiration time
		return FactionMeta.new(factionData) -- Returns new faction object with metatable
	end
	
	return nil -- Returns nil if faction doesn't exist
end

-- Get faction by join code (reverse lookup)
function Factions.GetFactionByJoinCode(joinCode) -- Function that finds faction using join code
	local success, factionName = pcall(function() -- Wraps GetAsync in pcall
		return FactionJoinCodes:GetAsync(joinCode) -- Looks up faction name using join code as key
	end)
	
	if not success or not factionName then -- Checks if lookup failed or returned nil
		return nil, "Invalid join code" -- Returns nil and error message
	end
	
	return Factions.GetFactionInfo(factionName) -- Returns faction object by calling GetFactionInfo
end

-- FACTION CREATION

-- Create a new faction
function Factions.CreateFaction(factionName, creatorUserId) -- Function that creates a new faction with initial data structure
	local generatedCode = generateJoinCode() -- Generates random 7-digit join code
	
	local success, result = pcall(function() -- Wraps UpdateAsync in pcall
		return FactionsStore:UpdateAsync(factionName, function(oldData) -- Uses UpdateAsync for atomic creation
			if oldData then -- Checks if faction already exists
				return nil -- Returns nil to abort creation
			end
			
			return { -- Returns new faction data structure
				Name = factionName, -- Sets faction name
				Leader = creatorUserId, -- Sets creator as leader
				Ranks = { -- Initializes ranks array with two default ranks
					{ -- Leader rank object
						RankName = "Leader", -- Sets rank name string
						RankNumber = LEADER_RANK_NUMBER, -- Sets rank number to maximum (20)
						Permissions = { -- Sets all permissions to true for leader
							RankMembers = true,
							KickMembers = true,
							ManageRanks = true,
							ManageArmory = true,
							WithdrawThaler = true,
							ManageFaction = true,
							EditArmor = true,
							EditImage = true,
							SetColor = true,
							GenerateJoinCode = true
						}
					},
					{ -- Member rank object
						RankName = "Member", -- Sets default rank name
						RankNumber = DEFAULT_RANK_NUMBER, -- Sets rank number to 1
						Permissions = { -- Sets all permissions to false for basic members
							RankMembers = false,
							KickMembers = false,
							ManageRanks = false,
							ManageArmory = false,
							WithdrawThaler = false,
							ManageFaction = false,
							EditArmor = false,
							EditImage = false,
							SetColor = false,
							GenerateJoinCode = false
						}
					}
				},
				Members = { -- Initializes Members dictionary with creator as first member
					[tostring(creatorUserId)] = "Leader" -- Assigns Leader rank to creator
				},
				Thaler = 0, -- Initializes faction currency to 0
				Armory = {}, -- Initializes empty armory array
				Renown = 0, -- Initializes renown points to 0
				ShirtId = "86956097495632", -- Sets default shirt asset ID
				PantsId = "122818513503376", -- Sets default pants asset ID
				ImageId = "7169354142", -- Sets default faction image asset ID
				Color = {r = 255, g = 255, b = 255}, -- Sets default color to white (RGB 255,255,255)
				JoinCode = generatedCode, -- Assigns generated join code
				Created = os.time(), -- Records creation timestamp
				Territory = nil -- Initializes territory as nil (unclaimed)
			}
		end)
	end)
	
	if not success then -- Checks if UpdateAsync failed
		logError("CreateFaction", result) -- Logs error
		return false, "Failed to create faction" -- Returns failure status
	end
	
	if not result then -- Checks if faction already existed
		return false, "Faction already exists" -- Returns failure message
	end
	
	setCacheWithExpiration(factionName, result) -- Caches new faction data
	savePlayerFaction(creatorUserId, factionName) -- Saves creator's faction membership
	
	pcall(function() -- Wraps secondary DataStore operations in pcall
		RenownLeaderboard:SetAsync(factionName, 0) -- Adds faction to leaderboard with 0 renown
		FactionJoinCodes:SetAsync(generatedCode, factionName) -- Maps join code to faction name
	end)
	
	broadcastFactionUpdate(factionName, "Create") -- Broadcasts creation to other servers
	return true, "Faction created successfully" -- Returns success status
end

-- Upload/Import a premade faction (for migration purposes)
function Factions.UploadFaction(name, creatorId, color, imageId, renown, pantsId, shirtId, factionRanks, members) -- Function for importing existing faction data
	if not name or not creatorId then -- Checks if required parameters are missing
		return false, "Name and creatorId are required" -- Returns failure if missing required params
	end
	
	color = color or {r = 255, g = 255, b = 255} -- Uses provided color or defaults to white
	imageId = imageId or "7169354142" -- Uses provided imageId or defaults to standard image
	renown = renown or 0 -- Uses provided renown or defaults to 0
	pantsId = pantsId or "122818513503376" -- Uses provided pantsId or defaults to standard pants
	shirtId = shirtId or "86956097495632" -- Uses provided shirtId or defaults to standard shirt
	
	factionRanks = factionRanks or { -- Uses provided ranks or creates default rank structure
		{
			RankName = "Leader",
			RankNumber = LEADER_RANK_NUMBER,
			Permissions = {
				RankMembers = true,
				KickMembers = true,
				ManageRanks = true,
				ManageArmory = true,
				WithdrawThaler = true,
				ManageFaction = true,
				EditArmor = true,
				EditImage = true,
				SetColor = true,
				GenerateJoinCode = true
			}
		},
		{
			RankName = "Member",
			RankNumber = DEFAULT_RANK_NUMBER,
			Permissions = {
				RankMembers = false,
				KickMembers = false,
				ManageRanks = false,
				ManageArmory = false,
				WithdrawThaler = false,
				ManageFaction = false,
				EditArmor = false,
				EditImage = false,
				SetColor = false,
				GenerateJoinCode = false
			}
		}
	}
	
	members = members or {[tostring(creatorId)] = "Leader"} -- Uses provided members or defaults to creator as leader
	
	local success, result = pcall(function() -- Wraps UpdateAsync in pcall
		return FactionsStore:UpdateAsync(name, function(oldData) -- Uses UpdateAsync for atomic upload
			if oldData then -- Checks if faction name already exists
				return nil -- Returns nil to abort upload
			end
			
			return { -- Returns complete faction data structure
				Name = name, -- Sets faction name
				Leader = creatorId, -- Sets leader UserId
				Ranks = factionRanks, -- Sets rank array
				Members = members, -- Sets members dictionary
				Thaler = 0, -- Initializes currency to 0
				Armory = {}, -- Initializes empty armory
				Renown = renown, -- Sets imported renown value
				ShirtId = shirtId, -- Sets shirt ID
				PantsId = pantsId, -- Sets pants ID
				ImageId = imageId, -- Sets image ID
				Color = color, -- Sets color table
				JoinCode = generateJoinCode(), -- Generates new join code
				Created = os.time(), -- Sets creation timestamp
				Territory = nil -- Initializes territory as nil
			}
		end)
	end)
	
	if not success then -- Checks if upload failed
		logError("UploadFaction", result) -- Logs error
		return false, "Failed to upload faction" -- Returns failure status
	end
	
	if not result then -- Checks if faction already existed
		return false, "Faction already exists" -- Returns failure message
	end
	
	setCacheWithExpiration(name, result) -- Caches uploaded faction
	
	pcall(function() -- Wraps leaderboard update in pcall
		RenownLeaderboard:SetAsync(name, renown) -- Adds faction to leaderboard with imported renown
	end)
	
	broadcastFactionUpdate(name, "Create") -- Broadcasts creation to other servers
	return true, "Faction uploaded successfully" -- Returns success status
end

-- JOINING AND LEAVING FACTIONS

-- Join faction using faction name directly (optimized method)
function Factions.JoinFaction(userId, factionName) -- Function that adds a player to a faction
	local currentFaction = Factions.GetPlayerFaction(userId) -- Checks if player is already in a faction
	if currentFaction then -- If player has a current faction
		return false, "Already in a faction. Leave your current faction first." -- Returns error
	end
	
	local success, result = pcall(function() -- Wraps UpdateAsync in pcall
		return FactionsStore:UpdateAsync(factionName, function(factionData) -- Uses UpdateAsync for atomic member addition
			if not factionData then -- Checks if faction doesn't exist
				return nil -- Returns nil to abort join
			end
			
			local memberCount = 0 -- Initializes counter to 0
			for _ in pairs(factionData.Members) do -- Iterates through Members dictionary
				memberCount = memberCount + 1 -- Increments counter for each member
			end
			
			if memberCount >= MAX_MEMBERS then -- Checks if faction is at capacity
				return nil -- Returns nil to abort join
			end
			
			factionData.Members[tostring(userId)] = "Member" -- Adds new member with default rank
			return factionData -- Returns modified data to save
		end)
	end)
	
	if not success then -- Checks if join operation failed
		logError("JoinFaction", result) -- Logs error
		return false, "Failed to join faction" -- Returns failure status
	end
	
	if not result then -- Checks if faction doesn't exist or is full
		return false, "Faction not found or is full" -- Returns failure message
	end
	
	setCacheWithExpiration(factionName, result) -- Updates cache with new data
	savePlayerFaction(userId, factionName) -- Saves player's faction membership
	broadcastFactionUpdate(factionName, "Update") -- Broadcasts update to other servers
	return true, "Joined " .. factionName -- Returns success with faction name
end

-- Join faction using join code (invitations system)
function Factions.JoinFactionByJoinCode(userId, joinCode) -- Function that joins faction using invite code
	local success, factionName = pcall(function() -- Wraps code lookup in pcall
		return FactionJoinCodes:GetAsync(joinCode) -- Looks up faction name from join code
	end)
	
	if not success or not factionName then -- Checks if lookup failed or code is invalid
		return false, "Invalid join code" -- Returns error message
	end
	
	return Factions.JoinFaction(userId, factionName) -- Calls main join function with resolved faction name
end

-- Leave faction (leaders will delete the faction instead)
function Factions.LeaveFaction(userId) -- Function that removes player from their faction
	local factionName = Factions.GetPlayerFaction(userId) -- Gets player's current faction
	if not factionName then -- Checks if player is not in any faction
		return false, "Not in a faction" -- Returns error
	end
	
	local factionData = Factions.GetFactionInfo(factionName) -- Gets complete faction data
	if not factionData then -- Checks if faction doesn't exist
		return false, "Faction not found" -- Returns error
	end
	
	if factionData.Leader == userId then -- Checks if player is the faction leader
		return Factions.DeleteFaction(userId, factionName) -- Calls DeleteFaction instead for leaders
	end
	
	local success, result = pcall(function() -- Wraps UpdateAsync in pcall
		return FactionsStore:UpdateAsync(factionName, function(factionData) -- Uses UpdateAsync for atomic removal
			if not factionData then -- Checks if faction doesn't exist
				return nil -- Returns nil to abort
			end
			
			factionData.Members[tostring(userId)] = nil -- Removes member by setting to nil
			return factionData -- Returns modified data
		end)
	end)
	
	if not success then -- Checks if operation failed
		logError("LeaveFaction", result) -- Logs error
		return false, "Failed to leave faction" -- Returns failure
	end
	
	if not result then -- Checks if faction doesn't exist
		return false, "Faction doesn't exist" -- Returns error
	end
	
	setCacheWithExpiration(factionName, result) -- Updates cache
	savePlayerFaction(userId, nil) -- Clears player's faction membership
	broadcastFactionUpdate(factionName, "Update") -- Broadcasts update
	return true, "Left faction" -- Returns success
end

-- FACTION DELETION

-- Delete faction (leader only)
function Factions.DeleteFaction(userId, factionName) -- Function that completely removes a faction
	local memberIds = {} -- Initializes empty array to collect member UserIds
	
	local success, result = pcall(function() -- Wraps UpdateAsync in pcall
		return FactionsStore:UpdateAsync(factionName, function(factionData) -- Uses UpdateAsync for atomic deletion
			if not factionData then -- Checks if faction doesn't exist
				return nil -- Returns nil to abort
			end
			
			if factionData.Leader ~= userId then -- Checks if user is not the leader
				return nil -- Returns nil to deny deletion
			end
			
			for memberUserId in pairs(factionData.Members) do -- Iterates through Members dictionary
				table.insert(memberIds, tonumber(memberUserId)) -- Converts string userId to number and adds to array
			end
			
			return {} -- Returns empty table to mark for deletion
		end)
	end)
	
	if not success then -- Checks if deletion failed
		logError("DeleteFaction", result) -- Logs error
		return false, "Failed to delete faction" -- Returns failure
	end
	
	if not result then -- Checks if permission denied or faction doesn't exist
		return false, "Permission denied or faction doesn't exist" -- Returns error
	end
	
	for _, memberUserId in ipairs(memberIds) do -- Iterates through collected member UserIds
		savePlayerFaction(memberUserId, nil) -- Clears each member's faction membership
	end
	
	pcall(function() -- Wraps RemoveAsync in pcall
		FactionsStore:RemoveAsync(factionName) -- Permanently deletes faction from DataStore
	end)
	
	pcall(function() -- Wraps leaderboard removal in pcall
		RenownLeaderboard:RemoveAsync(factionName) -- Removes faction from renown leaderboard
	end)
	
	factionCache[factionName] = nil -- Clears faction from cache
	cacheExpirationTimes[factionName] = nil -- Removes expiration time entry
	pendingRenown[factionName] = nil -- Clears pending renown
	lastBroadcast[factionName] = nil -- Clears broadcast timestamp
	territoryCache[factionName] = nil -- Clears territory cache
	
	broadcastFactionUpdate(factionName, "Delete") -- Broadcasts deletion to other servers
	return true, "Faction deleted" -- Returns success
end

-- RANK MANAGEMENT

-- Set member's rank (requires RankMembers permission and rank hierarchy)
function Factions.SetMemberRank(promoterId, targetUserId, factionName, newRankName) -- Function that changes a member's rank
	if promoterId == targetUserId then -- Checks if trying to change own rank
		return false, "Cannot change your own rank" -- Returns error
	end
	
	local success, result = pcall(function() -- Wraps UpdateAsync in pcall
		return FactionsStore:UpdateAsync(factionName, function(factionData) -- Uses UpdateAsync for atomic rank change
			if not factionData then -- Checks if faction doesn't exist
				return nil -- Returns nil to abort
			end
			
			local faction = FactionMeta.new(factionData) -- Creates faction object from data
			
			if not faction:HasPermission(promoterId, "RankMembers") then -- Checks if promoter has permission
				return nil -- Returns nil to deny action
			end
			
			if not faction:IsMember(targetUserId) then -- Checks if target is a member
				return nil -- Returns nil if target not found
			end
			
			if not faction:CanManageUser(promoterId, targetUserId) then -- Checks rank hierarchy
				return nil -- Returns nil if hierarchy violation
			end
			
			local newRank = faction:FindRank(newRankName) -- Finds new rank object by name
			if not newRank then -- Checks if rank doesn't exist
				return nil -- Returns nil if invalid rank
			end
			
			local promoterRank = faction:GetMemberRank(promoterId) -- Gets promoter's rank
			if not promoterRank or newRank.RankNumber >= promoterRank.RankNumber then -- Checks if new rank is too high
				return nil -- Returns nil to prevent rank elevation beyond promoter
			end
			
			factionData.Members[tostring(targetUserId)] = newRankName -- Updates member's rank
			return factionData -- Returns modified data
		end)
	end)
	
	if not success then -- Checks if operation failed
		logError("SetMemberRank", result) -- Logs error
		return false, "Failed to set rank" -- Returns failure
	end
	
	if not result then -- Checks if denied
		return false, "Permission denied, invalid rank, or hierarchy violation" -- Returns error
	end
	
	setCacheWithExpiration(factionName, result) -- Updates cache
	broadcastFactionUpdate(factionName, "Update") -- Broadcasts update
	return true, "Rank updated" -- Returns success
end

-- Create a new rank (requires ManageRanks permission)
function Factions.CreateRank(userId, factionName, rankName, rankNumber, permissions) -- Function that creates new custom rank
	local success, result = pcall(function() -- Wraps UpdateAsync in pcall
		return FactionsStore:UpdateAsync(factionName, function(factionData) -- Uses UpdateAsync for atomic rank creation
			if not factionData then -- Checks if faction doesn't exist
				return nil -- Returns nil to abort
			end
			
			local faction = FactionMeta.new(factionData) -- Creates faction object
			
			if not faction:HasPermission(userId, "ManageRanks") then -- Checks permission
				return nil -- Returns nil to deny
			end
			
			if faction:FindRank(rankName) then -- Checks if rank name already exists
				return nil -- Returns nil to prevent duplicate
			end
			
			local creatorRank = faction:GetMemberRank(userId) -- Gets creator's rank
			if not creatorRank or rankNumber >= creatorRank.RankNumber then -- Checks if rank number is too high
				return nil -- Returns nil to prevent creating rank equal/higher than creator
			end
			
			table.insert(factionData.Ranks, { -- Inserts new rank into Ranks array
				RankName = rankName, -- Sets rank name
				RankNumber = rankNumber, -- Sets rank number
				Permissions = permissions or { -- Sets permissions or uses defaults
					RankMembers = false,
					KickMembers = false,
					ManageRanks = false,
					ManageArmory = false,
					WithdrawThaler = false,
					ManageFaction = false,
					EditArmor = false,
					EditImage = false,
					SetColor = false,
					GenerateJoinCode = false
				}
			})
			
			return factionData -- Returns modified data
		end)
	end)
	
	if not success then -- Checks if creation failed
		logError("CreateRank", result) -- Logs error
		return false, "Failed to create rank" -- Returns failure
	end
	
	if not result then -- Checks if denied
		return false, "Permission denied, rank exists, or invalid rank number" -- Returns error
	end
	
	setCacheWithExpiration(factionName, result) -- Updates cache
	broadcastFactionUpdate(factionName, "Update") -- Broadcasts update
	return true, "Rank created" -- Returns success
end

-- Delete a rank (requires ManageRanks permission)
function Factions.DeleteRank(userId, factionName, rankName) -- Function that deletes a custom rank
	local success, result = pcall(function() -- Wraps UpdateAsync in pcall
		return FactionsStore:UpdateAsync(factionName, function(factionData) -- Uses UpdateAsync for atomic deletion
			if not factionData then -- Checks if faction doesn't exist
				return nil -- Returns nil to abort
			end
			
			local faction = FactionMeta.new(factionData) -- Creates faction object
			
			if not faction:HasPermission(userId, "ManageRanks") then -- Checks permission
				return nil -- Returns nil to deny
			end
			
			if rankName == "Leader" or rankName == "Member" then -- Checks if trying to delete system rank
				return nil -- Returns nil to protect system ranks
			end
			
			local rankToDelete = faction:FindRank(rankName) -- Finds rank to delete
			if not rankToDelete then -- Checks if rank doesn't exist
				return nil -- Returns nil if not found
			end
			
			local deleterRank = faction:GetMemberRank(userId) -- Gets deleter's rank
			if not deleterRank or rankToDelete.RankNumber >= deleterRank.RankNumber then -- Checks hierarchy
				return nil -- Returns nil if trying to delete equal/higher rank
			end
			
			for _, memberRank in pairs(factionData.Members) do -- Iterates through all members
				if memberRank == rankName then -- Checks if any member has this rank
					return nil -- Returns nil to prevent deleting rank with active members
				end
			end
			
			for i, rank in ipairs(factionData.Ranks) do -- Iterates through Ranks array with index
				if rank.RankName == rankName then -- Finds matching rank
					table.remove(factionData.Ranks, i) -- Removes rank from array at index i
					break -- Exits loop after removal
				end
			end
			
			return factionData -- Returns modified data
		end)
	end)
	
	if not success then -- Checks if deletion failed
		logError("DeleteRank", result) -- Logs error
		return false, "Failed to delete rank" -- Returns failure
	end
	
	if not result then -- Checks if denied
		return false, "Permission denied, rank has members, or cannot delete this rank" -- Returns error
	end
	
	setCacheWithExpiration(factionName, result) -- Updates cache
	broadcastFactionUpdate(factionName, "Update") -- Broadcasts update
	return true, "Rank deleted" -- Returns success
end

-- Edit rank properties (requires ManageRanks permission)
function Factions.EditRank(userId, factionName, oldRankName, newRankName, newRankNumber, newPermissions) -- Function that modifies rank properties
	local success, result = pcall(function() -- Wraps UpdateAsync in pcall
		return FactionsStore:UpdateAsync(factionName, function(factionData) -- Uses UpdateAsync for atomic edit
			if not factionData then -- Checks if faction doesn't exist
				return nil -- Returns nil to abort
			end
			
			local faction = FactionMeta.new(factionData) -- Creates faction object
			
			if not faction:HasPermission(userId, "ManageRanks") then -- Checks permission
				return nil -- Returns nil to deny
			end
			
			if oldRankName == "Leader" then -- Checks if trying to edit Leader rank
				return nil -- Returns nil to protect Leader rank
			end
			
			local rank = faction:FindRank(oldRankName) -- Finds rank to edit
			if not rank then -- Checks if rank doesn't exist
				return nil -- Returns nil if not found
			end
			
			local editorRank = faction:GetMemberRank(userId) -- Gets editor's rank
			if not editorRank or rank.RankNumber >= editorRank.RankNumber then -- Checks hierarchy
				return nil -- Returns nil if trying to edit equal/higher rank
			end
			
			if newRankNumber then -- Checks if rank number is being changed
				if newRankNumber < 1 or newRankNumber > 19 or newRankNumber >= editorRank.RankNumber then -- Validates new rank number
					return nil -- Returns nil if invalid number
				end
				
				for _, r in ipairs(factionData.Ranks) do -- Iterates through existing ranks
					if r.RankNumber == newRankNumber and r.RankName ~= oldRankName then -- Checks for number conflicts
						return nil -- Returns nil if number already taken
					end
				end
				
				rank.RankNumber = newRankNumber -- Updates rank number
			end
			
			if newRankName and newRankName ~= oldRankName then -- Checks if rank is being renamed
				if newRankName == "Leader" or faction:FindRank(newRankName) then -- Checks for name conflicts
					return nil -- Returns nil if name invalid or taken
				end
				
				rank.RankName = newRankName -- Updates rank name
				
				for memberId, memberRankName in pairs(factionData.Members) do -- Iterates through all members
					if memberRankName == oldRankName then -- Checks if member has old rank name
						factionData.Members[memberId] = newRankName -- Updates member's rank to new name
					end
				end
			end
			
			if newPermissions then -- Checks if permissions are being updated
				rank.Permissions = newPermissions -- Replaces permissions table
			end
			
			return factionData -- Returns modified data
		end)
	end)
	
	if not success then -- Checks if edit failed
		logError("EditRank", result) -- Logs error
		return false, "Failed to edit rank" -- Returns failure
	end
	
	if not result then -- Checks if denied
		return false, "Permission denied, invalid rank, or name/number conflict" -- Returns error
	end
	
	setCacheWithExpiration(factionName, result) -- Updates cache
	broadcastFactionUpdate(factionName, "Update") -- Broadcasts update
	return true, "Rank updated" -- Returns success
end

-- Get faction members
function Factions.GetMembers(factionName) -- Function that retrieves faction's member dictionary
	local factionData = Factions.GetFactionInfo(factionName) -- Gets faction data
	if not factionData then -- Checks if faction doesn't exist
		return nil, "Faction not found" -- Returns nil and error
	end
	return factionData.Members -- Returns Members dictionary
end

-- Get faction ranks
function Factions.GetRanks(factionName) -- Function that retrieves faction's ranks array
	local factionData = Factions.GetFactionInfo(factionName) -- Gets faction data
	if not factionData then -- Checks if faction doesn't exist
		return nil, "Faction not found" -- Returns nil and error
	end
	return factionData.Ranks -- Returns Ranks array
end

-- LEADERSHIP TRANSFER

-- Transfer leadership to another member (leader only)
function Factions.TransferLeadership(currentLeaderId, newLeaderId, factionName) -- Function that transfers faction leadership
	if currentLeaderId == newLeaderId then -- Checks if trying to transfer to self
		return false, "Cannot transfer to yourself" -- Returns error
	end
	
	local success, result = pcall(function() -- Wraps UpdateAsync in pcall
		return FactionsStore:UpdateAsync(factionName, function(factionData) -- Uses UpdateAsync for atomic transfer
			if not factionData then -- Checks if faction doesn't exist
				return nil -- Returns nil to abort
			end
			
			if factionData.Leader ~= currentLeaderId then -- Checks if current user is leader
				return nil -- Returns nil to deny transfer
			end
			
			if not factionData.Members[tostring(newLeaderId)] then -- Checks if new leader is member
				return nil -- Returns nil if new leader not in faction
			end
			
			factionData.Members[tostring(currentLeaderId)] = "Member" -- Demotes old leader to Member rank
			factionData.Members[tostring(newLeaderId)] = "Leader" -- Promotes new leader to Leader rank
			factionData.Leader = newLeaderId -- Updates Leader property to new leader's UserId
			
			return factionData -- Returns modified data
		end)
	end)
	
	if not success then -- Checks if transfer failed
		logError("TransferLeadership", result) -- Logs error
		return false, "Failed to transfer leadership" -- Returns failure
	end
	
	if not result then -- Checks if denied
		return false, "Permission denied or new leader not in faction" -- Returns error
	end
	
	setCacheWithExpiration(factionName, result) -- Updates cache
	broadcastFactionUpdate(factionName, "Update") -- Broadcasts update
	return true, "Leadership transferred" -- Returns success
end

-- CURRENCY SYSTEM (THALER)

-- Deposit Thaler into faction bank
function Factions.DepositThaler(userId, factionName, amount) -- Function that adds currency to faction
	if amount <= 0 then -- Checks if amount is not positive
		return false, "Amount must be positive" -- Returns error
	end
	
	local canProceed, err = checkPlayerRateLimit(userId, "DepositThaler") -- Checks rate limit
	if not canProceed then -- If rate limit exceeded
		return false, err -- Returns false and error message
	end
	
	local success, result = pcall(function() -- Wraps UpdateAsync in pcall
		return FactionsStore:UpdateAsync(factionName, function(factionData) -- Uses UpdateAsync for atomic deposit
			if not factionData then -- Checks if faction doesn't exist
				return nil -- Returns nil to abort
			end
			
			if not factionData.Members[tostring(userId)] then -- Checks if user is member
				return nil -- Returns nil to deny deposit
			end
			
			factionData.Thaler = (factionData.Thaler or 0) + amount -- Adds amount to Thaler, initializing to 0 if nil
			return factionData -- Returns modified data
		end)
	end)
	
	if not success then -- Checks if deposit failed
		logError("DepositThaler", result) -- Logs error
		return false, "Failed to deposit" -- Returns failure
	end
	
	if not result then -- Checks if denied
		return false, "Not a member of this faction" -- Returns error
	end
	
	setCacheWithExpiration(factionName, result) -- Updates cache
	broadcastFactionUpdate(factionName, "Update") -- Broadcasts update
	return true, "Deposited " .. amount .. " Thaler" -- Returns success with amount
end

-- Withdraw Thaler from faction bank (requires WithdrawThaler permission)
function Factions.WithdrawThaler(userId, factionName, amount) -- Function that removes currency from faction
	if amount <= 0 then -- Checks if amount is not positive
		return false, "Amount must be positive" -- Returns error
	end
	
	local canProceed, err = checkPlayerRateLimit(userId, "WithdrawThaler") -- Checks rate limit
	if not canProceed then -- If rate limit exceeded
		return false, err -- Returns false and error message
	end
	
	local success, result = pcall(function() -- Wraps UpdateAsync in pcall
		return FactionsStore:UpdateAsync(factionName, function(factionData) -- Uses UpdateAsync for atomic withdrawal
			if not factionData then -- Checks if faction doesn't exist
				return nil -- Returns nil to abort
			end
			
			local faction = FactionMeta.new(factionData) -- Creates faction object
			
			if not faction:HasPermission(userId, "WithdrawThaler") then -- Checks permission
				return nil -- Returns nil to deny
			end
			
			local currentThaler = factionData.Thaler or 0 -- Gets current Thaler amount, defaulting to 0
			
			if currentThaler < amount then -- Checks if sufficient funds available
				return nil -- Returns nil if insufficient funds
			end
			
			factionData.Thaler = currentThaler - amount -- Subtracts withdrawal amount from current Thaler
			return factionData -- Returns modified data
		end)
	end)
	
	if not success then -- Checks if withdrawal failed
		logError("WithdrawThaler", result) -- Logs error
		return false, "Failed to withdraw" -- Returns failure
	end
	
	if not result then -- Checks if denied
		return false, "Permission denied or insufficient funds" -- Returns error
	end
	
	setCacheWithExpiration(factionName, result) -- Updates cache
	broadcastFactionUpdate(factionName, "Update") -- Broadcasts update
	return true, "Withdrew " .. amount .. " Thaler" -- Returns success with amount
end

-- Get Thaler balance
function Factions.GetThalerBalance(factionName) -- Function that retrieves faction's currency balance
	local factionData = Factions.GetFactionInfo(factionName) -- Gets faction data
	if not factionData then -- Checks if faction doesn't exist
		return nil, "Faction not found" -- Returns nil and error
	end
	return factionData.Thaler or 0 -- Returns Thaler amount, defaulting to 0 if nil
end

-- ARMORY SYSTEM

-- Add item to faction armory
function Factions.AddArmoryItem(userId, factionName, itemName) -- Function that adds item to faction armory
	local canProceed, err = checkPlayerRateLimit(userId, "ArmoryOperation") -- Checks rate limit
	if not canProceed then -- If rate limit exceeded
		return false, err -- Returns false and error message
	end
	
	local success, result = pcall(function() -- Wraps UpdateAsync in pcall
		return FactionsStore:UpdateAsync(factionName, function(factionData) -- Uses UpdateAsync for atomic item addition
			if not factionData then -- Checks if faction doesn't exist
				return nil -- Returns nil to abort
			end
			
			if not factionData.Members[tostring(userId)] then -- Checks if user is member
				return nil -- Returns nil to deny
			end
			
			factionData.Armory = factionData.Armory or {} -- Initializes Armory array if nil
			
			if #factionData.Armory >= ARMORY_CAPACITY then -- Checks if armory is at capacity using length operator
				return nil -- Returns nil if armory full
			end
			
			table.insert(factionData.Armory, itemName) -- Inserts item name into Armory array
			return factionData -- Returns modified data
		end)
	end)
	
	if not success then -- Checks if addition failed
		logError("AddArmoryItem", result) -- Logs error
		return false, "Failed to add item" -- Returns failure
	end
	
	if not result then -- Checks if denied
		return false, "Not a member, or armory is full (capacity: " .. ARMORY_CAPACITY .. ")" -- Returns error with capacity
	end
	
	setCacheWithExpiration(factionName, result) -- Updates cache
	broadcastFactionUpdate(factionName, "Update") -- Broadcasts update
	return true, "Added " .. itemName .. " to armory" -- Returns success with item name
end

-- Remove item from armory (requires ManageArmory permission)
function Factions.RemoveArmoryItem(userId, factionName, itemName) -- Function that removes item from armory
	local canProceed, err = checkPlayerRateLimit(userId, "ArmoryOperation") -- Checks rate limit
	if not canProceed then -- If rate limit exceeded
		return false, err -- Returns false and error message
	end
	
	local success, result = pcall(function() -- Wraps UpdateAsync in pcall
		return FactionsStore:UpdateAsync(factionName, function(factionData) -- Uses UpdateAsync for atomic item removal
			if not factionData then -- Checks if faction doesn't exist
				return nil -- Returns nil to abort
			end
			
			local faction = FactionMeta.new(factionData) -- Creates faction object
			
			if not faction:HasPermission(userId, "ManageArmory") then -- Checks permission
				return nil -- Returns nil to deny
			end
			
			factionData.Armory = factionData.Armory or {} -- Initializes Armory if nil
			
			for i, item in ipairs(factionData.Armory) do -- Iterates through Armory array with index
				if item == itemName then -- Checks if current item matches target
					table.remove(factionData.Armory, i) -- Removes item at index i
					return factionData -- Returns modified data
				end
			end
			
			return nil -- Returns nil if item not found
		end)
	end)
	
	if not success then -- Checks if removal failed
		logError("RemoveArmoryItem", result) -- Logs error
		return false, "Failed to remove item" -- Returns failure
	end
	
	if not result then -- Checks if denied or not found
		return false, "Permission denied or item not found" -- Returns error
	end
	
	setCacheWithExpiration(factionName, result) -- Updates cache
	broadcastFactionUpdate(factionName, "Update") -- Broadcasts update
	return true, "Removed " .. itemName .. " from armory" -- Returns success with item name
end

-- Get armory contents
function Factions.GetArmory(factionName) -- Function that retrieves faction's armory array
	local factionData = Factions.GetFactionInfo(factionName) -- Gets faction data
	if not factionData then -- Checks if faction doesn't exist
		return nil, "Faction not found" -- Returns nil and error
	end
	return factionData.Armory or {} -- Returns Armory array, defaulting to empty array if nil
end

-- RENOWN SYSTEM

-- Give renown to faction (batched for optimization)
function Factions.GiveRenown(factionName, amount) -- Function that adds renown points to faction
	if amount <= 0 then -- Checks if amount is not positive
		return false, "Amount must be positive" -- Returns error
	end
	
	return accumulateRenown(factionName, amount) -- Calls accumulation function which batches writes
end

-- Get faction's current renown (includes pending batched renown)
function Factions.GetRenown(factionName) -- Function that retrieves faction's total renown
	local factionData = Factions.GetFactionInfo(factionName) -- Gets faction data
	if not factionData then -- Checks if faction doesn't exist
		return nil, "Faction not found" -- Returns nil and error
	end
	
	return factionData:GetRenown() -- Calls GetRenown method which includes pending renown
end

-- Get renown leaderboard
function Factions.GetLeaderboard(limit) -- Function that retrieves sorted leaderboard of top factions
	limit = limit or 10 -- Uses provided limit or defaults to 10
	local leaderboard = {} -- Initializes empty leaderboard array
	
	local success, pages = pcall(function() -- Wraps GetSortedAsync in pcall
		return RenownLeaderboard:GetSortedAsync(false, limit) -- Gets sorted pages in descending order (false) with limit
	end)
	
	if not success then -- Checks if retrieval failed
		logError("GetLeaderboard", pages) -- Logs error
		return leaderboard -- Returns empty leaderboard
	end
	
	local topFactions = pages:GetCurrentPage() -- Gets current page of results as array
	
	for _, entry in ipairs(topFactions) do -- Iterates through leaderboard entries
		local pendingAmount = pendingRenown[entry.key] or 0 -- Gets pending renown for faction, defaulting to 0
		table.insert(leaderboard, { -- Inserts entry into leaderboard array
			Name = entry.key, -- Sets faction name from entry key
			Renown = entry.value + pendingAmount -- Adds stored and pending renown
		})
	end
	
	return leaderboard -- Returns populated leaderboard array
end

-- MEMBER MANAGEMENT

-- Kick member from faction (requires KickMembers permission and rank hierarchy)
function Factions.KickMember(kickerId, targetUserId, factionName) -- Function that removes member from faction
	if kickerId == targetUserId then -- Checks if trying to kick self
		return false, "Cannot kick yourself (use LeaveFaction instead)" -- Returns error
	end
	
	local success, result = pcall(function() -- Wraps UpdateAsync in pcall
		return FactionsStore:UpdateAsync(factionName, function(factionData) -- Uses UpdateAsync for atomic kick
			if not factionData then -- Checks if faction doesn't exist
				return nil -- Returns nil to abort
			end
			
			local faction = FactionMeta.new(factionData) -- Creates faction object
			
			if not faction:HasPermission(kickerId, "KickMembers") then -- Checks permission
				return nil -- Returns nil to deny
			end
			
			if not faction:IsMember(targetUserId) then -- Checks if target is member
				return nil -- Returns nil if target not found
			end
			
			if not faction:CanManageUser(kickerId, targetUserId) then -- Checks rank hierarchy
				return nil -- Returns nil if hierarchy violation
			end
			
			factionData.Members[tostring(targetUserId)] = nil -- Removes member by setting to nil
			return factionData -- Returns modified data
		end)
	end)
	
	if not success then -- Checks if kick failed
		logError("KickMember", result) -- Logs error
		return false, "Failed to kick member" -- Returns failure
	end
	
	if not result then -- Checks if denied
		return false, "Permission denied or target cannot be kicked" -- Returns error
	end
	
	setCacheWithExpiration(factionName, result) -- Updates cache
	savePlayerFaction(targetUserId, nil) -- Clears kicked player's faction membership
	broadcastFactionUpdate(factionName, "Update") -- Broadcasts update
	
	pcall(function() -- Wraps PublishAsync in pcall
		MessagingService:PublishAsync(FACTION_KICK_TOPIC, { -- Publishes kick notification to all servers
			UserId = targetUserId, -- Includes kicked player's UserId
			Timestamp = os.time() -- Includes current timestamp
		})
	end)
	
	return true, "Player kicked from faction" -- Returns success
end

-- CUSTOMIZATION SYSTEM

-- Set faction shirt ID (requires EditArmor permission)
function Factions.SetShirtId(userId, factionName, shirtId) -- Function that updates faction's shirt asset ID
	local success, result = pcall(function() -- Wraps UpdateAsync in pcall
		return FactionsStore:UpdateAsync(factionName, function(factionData) -- Uses UpdateAsync for atomic update
			if not factionData then -- Checks if faction doesn't exist
				return nil -- Returns nil to abort
			end
			
			local faction = FactionMeta.new(factionData) -- Creates faction object
			
			if not faction:HasPermission(userId, "EditArmor") then -- Checks permission
				return nil -- Returns nil to deny
			end
			
			factionData.ShirtId = shirtId -- Updates ShirtId property with new asset ID
			return factionData -- Returns modified data
		end)
	end)
	
	if not success then -- Checks if update failed
		logError("SetShirtId", result) -- Logs error
		return false, "Failed to set shirt ID" -- Returns failure
	end
	
	if not result then -- Checks if denied
		return false, "Permission denied" -- Returns error
	end
	
	setCacheWithExpiration(factionName, result) -- Updates cache
	broadcastFactionUpdate(factionName, "Update") -- Broadcasts update
	return true, "Shirt ID updated" -- Returns success
end

-- Set faction pants ID (requires EditArmor permission)
function Factions.SetPantsId(userId, factionName, pantsId) -- Function that updates faction's pants asset ID
	local success, result = pcall(function() -- Wraps UpdateAsync in pcall
		return FactionsStore:UpdateAsync(factionName, function(factionData) -- Uses UpdateAsync for atomic update
			if not factionData then -- Checks if faction doesn't exist
				return nil -- Returns nil to abort
			end
			
			local faction = FactionMeta.new(factionData) -- Creates faction object
			
			if not faction:HasPermission(userId, "EditArmor") then -- Checks permission
				return nil -- Returns nil to deny
			end
			
			factionData.PantsId = pantsId -- Updates PantsId property with new asset ID
			return factionData -- Returns modified data
		end)
	end)
	
	if not success then -- Checks if update failed
		logError("SetPantsId", result) -- Logs error
		return false, "Failed to set pants ID" -- Returns failure
	end
	
	if not result then -- Checks if denied
		return false, "Permission denied" -- Returns error
	end
	
	setCacheWithExpiration(factionName, result) -- Updates cache
	broadcastFactionUpdate(factionName, "Update") -- Broadcasts update
	return true, "Pants ID updated" -- Returns success
end

-- Set faction image ID (requires EditImage permission)
function Factions.SetImageId(userId, factionName, imageId) -- Function that updates faction's image asset ID
	local success, result = pcall(function() -- Wraps UpdateAsync in pcall
		return FactionsStore:UpdateAsync(factionName, function(factionData) -- Uses UpdateAsync for atomic update
			if not factionData then -- Checks if faction doesn't exist
				return nil -- Returns nil to abort
			end
			
			local faction = FactionMeta.new(factionData) -- Creates faction object
			
			if not faction:HasPermission(userId, "EditImage") then -- Checks permission
				return nil -- Returns nil to deny
			end
			
			factionData.ImageId = imageId -- Updates ImageId property with new asset ID
			return factionData -- Returns modified data
		end)
	end)
	
	if not success then -- Checks if update failed
		logError("SetImageId", result) -- Logs error
		return false, "Failed to set image ID" -- Returns failure
	end
	
	if not result then -- Checks if denied
		return false, "Permission denied" -- Returns error
	end
	
	setCacheWithExpiration(factionName, result) -- Updates cache
	broadcastFactionUpdate(factionName, "Update") -- Broadcasts update
	return true, "Image ID updated" -- Returns success
end

-- Set faction color (requires SetColor permission)
function Factions.SetColor(userId, factionName, r, g, b) -- Function that updates faction's RGB color
	if r < 0 or r > 255 or g < 0 or g > 255 or b < 0 or b > 255 then -- Validates RGB values are in range 0-255
		return false, "RGB values must be between 0 and 255" -- Returns error for invalid values
	end
	
	local success, result = pcall(function() -- Wraps UpdateAsync in pcall
		return FactionsStore:UpdateAsync(factionName, function(factionData) -- Uses UpdateAsync for atomic update
			if not factionData then -- Checks if faction doesn't exist
				return nil -- Returns nil to abort
			end
			
			local faction = FactionMeta.new(factionData) -- Creates faction object
			
			if not faction:HasPermission(userId, "SetColor") then -- Checks permission
				return nil -- Returns nil to deny
			end
			
			factionData.Color = {r = r, g = g, b = b} -- Creates new Color table with RGB values
			return factionData -- Returns modified data
		end)
	end)
	
	if not success then -- Checks if update failed
		logError("SetColor", result) -- Logs error
		return false, "Failed to set color" -- Returns failure
	end
	
	if not result then -- Checks if denied
		return false, "Permission denied" -- Returns error
	end
	
	setCacheWithExpiration(factionName, result) -- Updates cache
	broadcastFactionUpdate(factionName, "Update") -- Broadcasts update
	return true, "Color updated" -- Returns success
end

-- Regenerate faction join code (requires GenerateJoinCode permission)
function Factions.RegenerateJoinCode(userId, factionName) -- Function that generates new join code for faction
	local newCode = generateJoinCode() -- Generates new random 7-digit code
	
	local factionData = Factions.GetFactionInfo(factionName) -- Gets current faction data
	if not factionData then -- Checks if faction doesn't exist
		return false, "Faction not found" -- Returns error
	end
	
	local oldJoinCode = factionData.JoinCode -- Stores old join code for cleanup
	
	local success, result = pcall(function() -- Wraps UpdateAsync in pcall
		return FactionsStore:UpdateAsync(factionName, function(factionData) -- Uses UpdateAsync for atomic update
			if not factionData then -- Checks if faction doesn't exist
				return nil -- Returns nil to abort
			end
			
			local faction = FactionMeta.new(factionData) -- Creates faction object
			
			if not faction:HasPermission(userId, "GenerateJoinCode") then -- Checks permission
				return nil -- Returns nil to deny
			end
			
			factionData.JoinCode = newCode -- Updates JoinCode property with new code
			return factionData -- Returns modified data
		end)
	end)
	
	if not success then -- Checks if update failed
		logError("RegenerateJoinCode", result) -- Logs error
		return false, "Failed to regenerate join code" -- Returns failure
	end
	
	if not result then -- Checks if denied
		return false, "Permission denied" -- Returns error
	end
	
	pcall(function() -- Wraps join code updates in pcall
		FactionJoinCodes:SetAsync(newCode, factionName) -- Maps new code to faction name
		FactionJoinCodes:RemoveAsync(oldJoinCode) -- Removes old code mapping
	end)
	
	setCacheWithExpiration(factionName, result) -- Updates cache
	broadcastFactionUpdate(factionName, "Update") -- Broadcasts update
	return true, "Join code regenerated: " .. newCode -- Returns success with new code
end

-- TERRITORY SYSTEM (CFrame/Vector3 Mathematics)

-- Claim territory at a position (requires ManageFaction permission)
function Factions.ClaimTerritory(userId, factionName, centerPosition, radius) -- Function that claims territory sphere for faction
	radius = radius or TERRITORY_RADIUS -- Uses provided radius or defaults to constant
	
	if typeof(centerPosition) ~= "Vector3" then -- Validates centerPosition is Vector3 type using typeof()
		return false, "Invalid position (must be Vector3)" -- Returns error for invalid type
	end
	
	if radius <= 0 or radius > 500 then -- Validates radius is within acceptable range
		return false, "Radius must be between 1 and 500 studs" -- Returns error for invalid radius
	end
	
	local success, result = pcall(function() -- Wraps UpdateAsync in pcall
		return FactionsStore:UpdateAsync(factionName, function(factionData) -- Uses UpdateAsync for atomic claim
			if not factionData then -- Checks if faction doesn't exist
				return nil -- Returns nil to abort
			end
			
			local faction = FactionMeta.new(factionData) -- Creates faction object
			
			if not faction:HasPermission(userId, "ManageFaction") then -- Checks permission
				return nil -- Returns nil to deny
			end
			
			factionData.Territory = { -- Creates Territory table
				Center = centerPosition, -- Stores Vector3 center position
				Radius = radius, -- Stores numeric radius in studs
				ClaimedAt = os.time() -- Stores Unix timestamp of claim
			}
			
			return factionData -- Returns modified data
		end)
	end)
	
	if not success then -- Checks if claim failed
		logError("ClaimTerritory", result) -- Logs error
		return false, "Failed to claim territory" -- Returns failure
	end
	
	if not result then -- Checks if denied
		return false, "Permission denied or faction not found" -- Returns error
	end
	
	territoryCache[factionName] = result.Territory -- Caches territory data for quick spatial lookups
	
	setCacheWithExpiration(factionName, result) -- Updates faction cache
	broadcastFactionUpdate(factionName, "Update") -- Broadcasts update
	return true, "Territory claimed" -- Returns success
end

-- Check if a position is within faction territory
function Factions.IsPositionInTerritory(factionName, position) -- Function that checks if Vector3 position is in faction's territory
	if typeof(position) ~= "Vector3" then -- Validates position is Vector3 type
		return false, "Invalid position (must be Vector3)" -- Returns error for invalid type
	end
	
	local factionData = Factions.GetFactionInfo(factionName) -- Gets faction data
	if not factionData then -- Checks if faction doesn't exist
		return false, "Faction not found" -- Returns error
	end
	
	return factionData:IsPositionInTerritory(position) -- Calls metatable method that uses Vector3 math to check distance
end

-- Get faction that owns a position (checks all factions)
function Factions.GetTerritoryOwner(position) -- Function that finds which faction owns a position
	if typeof(position) ~= "Vector3" then -- Validates position is Vector3 type
		return nil, "Invalid position (must be Vector3)" -- Returns nil and error for invalid type
	end
	
	for factionName, territory in pairs(territoryCache) do -- Iterates through cached territories
		local displacement = position - territory.Center -- Calculates displacement Vector3 by subtracting center from position
		if displacement.Magnitude <= territory.Radius then -- Checks if distance (magnitude) is within radius
			return factionName -- Returns faction name if position is inside
		end
	end
	
	return nil -- Returns nil if position not in any territory
end

-- Remove faction territory (requires ManageFaction permission)
function Factions.RemoveTerritory(userId, factionName) -- Function that removes faction's territory claim
	local success, result = pcall(function() -- Wraps UpdateAsync in pcall
		return FactionsStore:UpdateAsync(factionName, function(factionData) -- Uses UpdateAsync for atomic removal
			if not factionData then -- Checks if faction doesn't exist
				return nil -- Returns nil to abort
			end
			
			local faction = FactionMeta.new(factionData) -- Creates faction object
			
			if not faction:HasPermission(userId, "ManageFaction") then -- Checks permission
				return nil -- Returns nil to deny
			end
			
			factionData.Territory = nil -- Sets Territory to nil to remove claim
			return factionData -- Returns modified data
		end)
	end)
	
	if not success then -- Checks if removal failed
		logError("RemoveTerritory", result) -- Logs error
		return false, "Failed to remove territory" -- Returns failure
	end
	
	if not result then -- Checks if denied
		return false, "Permission denied or faction not found" -- Returns error
	end
	
	territoryCache[factionName] = nil -- Removes territory from cache
	setCacheWithExpiration(factionName, result) -- Updates faction cache
	broadcastFactionUpdate(factionName, "Update") -- Broadcasts update
	return true, "Territory removed" -- Returns success
end

-- CLEANUP AND SHUTDOWN

-- Clear player cache when they leave the game
Players.PlayerRemoving:Connect(function(player) -- Connects to PlayerRemoving event
	playerFactionCache[player.UserId] = nil -- Removes player's cached faction by setting to nil
	playerLastRequest[player.UserId] = nil -- Removes player's rate limit data by setting to nil
end)

-- Flush all pending data on server shutdown
game:BindToClose(function() -- Registers shutdown callback that runs when server closes
	Factions.ForceFlushAllRenown() -- Immediately flushes all pending renown to DataStore
	
	task.wait(3) -- Waits 3 seconds to allow DataStore operations to complete
end)

return Factions -- Returns the Factions module table, making all functions accessible to requiring scripts
